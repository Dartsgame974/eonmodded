local a=require"cc.expect"local b=require"cc.audio.dfpwm"local c,d,e,f,g,h=bit32.band,bit32.bxor,bit32.lshift,bit32.rshift,bit32.btest,bit32.extract;local i,j,k,l,m,n,o,p=math.floor,math.ceil,math.sin,math.abs,math.fmod,math.min,math.max,math.pi;local q,r,s=os.epoch,os.queueEvent,os.pullEvent;local t,u,v,w,x=string.pack,string.unpack,string.sub,string.byte,string.rep;local y,z,A,B=table.pack,table.unpack,table.insert,table.remove;local C=setmetatable({},{__call=function(C,D)a(1,D,"string")local E=assert(fs.open(D,"rb"))local type=C.detect(E.read(64))or"dfpwm"E.seek("set",0)C.play(C.stream[type](function()return E.read(48000)end),peripheral.find("speaker"))E.close()end})C.effects,C.stream={},{}C._VERSION="1.7.0"C.defaultInterpolation="linear"local F={}local G;F.sampleRate=nil;F.metadata=nil;F.info=nil;local H="3ac1fa38-811d-4361-a40d-ce53ca607cd1"local function I(J)return J:gsub("-",""):gsub("%x%x",function(K)return string.char(tonumber(K,16))end)end;local L=jit and 30 or 10;local M={dfpwm=I(H),pcm=I"01000000-0000-1000-8000-00aa00389b71",msadpcm=I"02000000-0000-1000-8000-00aa00389b71",alaw=I"06000000-0000-1000-8000-00aa00389b71",ulaw=I"07000000-0000-1000-8000-00aa00389b71",adpcm=I"11000000-0000-1000-8000-00aa00389b71",pcm_float=I"03000000-0000-1000-8000-00aa00389b71"}local N={0x04,0x03,0x07,0x33,0x37,0x3F,0x637,0x63F,0x50F7,0x50FF,0x56F7,0x56FF}local O={[0]=-1,-1,-1,-1,2,4,6,8,-1,-1,-1,-1,2,4,6,8}local P={[0]=7,8,9,10,11,12,13,14,16,17,19,21,23,25,28,31,34,37,41,45,50,55,60,66,73,80,88,97,107,118,130,143,157,173,190,209,230,253,279,307,337,371,408,449,494,544,598,658,724,796,876,963,1060,1166,1282,1411,1552,1707,1878,2066,2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,15289,16818,18500,20350,22385,24623,27086,29794,32767}local Q={[0]=230,230,230,230,307,409,512,614,[-8]=768,[-7]=614,[-6]=512,[-5]=409,[-4]=307,[-3]=230,[-2]=230,[-1]=230}local R={tracknumber="trackNumber",["encoded-by"]="encodedBy",sourcemedia="sourceMedia",labelno="labelNumber",discnumber="discNumber",partnumber="partNumber",productnumber="productNumber",catalognumber="catalogNumber",["release date"]="releaseDate",["source medium"]="sourceMedium",["source artist"]="sourceArtist",["guest artist"]="guestArtist",["source work"]="sourceWork",disctotal="discCount",tracktotal="trackCount",parttotal="partCount",tcm="composer"}local S={IPRD="album",INAM="title",IART="artist",IWRI="author",IMUS="composer",IPRO="producer",IPRT="trackNumber",ITRK="trackNumber",IFRM="trackCount",PRT1="partNumber",PRT2="partCount",TLEN="length",IRTD="rating",ICRD="date",ITCH="encodedBy",ISFT="encoder",ISRF="media",IGNR="genre",ICMT="comment",ICOP="copyright",ILNG="language"}local function T(U,V)local W={utf8.codepoint(U,1,-1)}for X,Y in ipairs(W)do if Y>0xFF then W[X]=0x3F end end;return string.char(z(W)),V end;local function Z(_,a0,a1)if _<a0 then return a0 elseif _>a1 then return a1 else return _ end end;local function a2(_,a3)if type(a3)=="table"and getmetatable(a3)==G then return a3 end;a(_,a3,"Audio")end;local function a4(a5)local a6={}for a7,Y in pairs(a5)do a6[a7]=Y end;return a6 end;local function a8(U,V,a9,aa,ab)local _=0;if ab then for X=0,a9-1 do _=_*256+w(U,V+X)end else for X=0,a9-1 do _=_+w(U,V+X)*2^(8*X)end end;if aa and _>=2^(a9*8-1)then _=_-2^(a9*8)end;return _,V+a9 end;local ac={none=function(ad,ae)return ad[i(ae)]end,linear=function(ad,ae)local af=i(ae)return ad[af]+((ad[af+1]or ad[af])-ad[af])*(ae-af)end,cubic=function(ad,ae)local af=i(ae)local ag,ah,ai,aj,ak=ad[af-1],ad[af],ad[af+1],ad[af+2],ae-af;ag,ai,aj=ag or ah,ai or ah,aj or ai or ah;return(-0.5*ag+1.5*ah-1.5*ai+0.5*aj)*ak^3+(ag-2.5*ah+2*ai-0.5*aj)*ak^2+(-0.5*ag+0.5*ai)*ak+ah end,sinc=function(ad,ae)local af=i(ae)local ak=ae-af;local al=0;for _=-L,L do local am=af+_;local an=ad[am]if an then local ao=p*(ak-_)if ao==0 then al=al+an else al=al+an*k(ao)/ao end end end;return al end}local ap={none=1,linear=1,cubic=0,sinc=0}local aq={none=1,linear=2,cubic=3,sinc=0}local ar={sine=function(ae,as,at)return k(2*ae*p*as)*at end,triangle=function(ae,as,at)return 2.0*l(at*m(2.0*ae*as+1.5,2.0)-at)-at end,square=function(ae,as,at,au)if ae*as%1>=au then return-at else return at end end,sawtooth=function(ae,as,at)return at*m(2.0*ae*as+1.0,2.0)-at end}local av;do local aw={{},{1},{2,-1},{3,-3,1},{4,-6,4,-1}}local function ax(ad,V)local ay={}local az,aA=0,0;function ay.alignToByte()aA=aA-aA%8 end;function ay.readByte()return ay.readUint(8)end;function ay.readUint(_)if _==0 then return 0 end;while aA<_ do local aB=w(ad,V)V=V+1;if aB==nil then return nil end;az=(az*256+aB)%0x100000000000;aA=aA+8 end;aA=aA-_;local aC=i(az/2^aA)if _<32 then aC=aC%2^_ end;return aC end;function ay.readSignedInt(_)local Y=ay.readUint(_)if Y>=2^(_-1)then Y=Y-2^_ end;return Y end;function ay.readRiceSignedInt(aD)local aE=0;while ay.readUint(1)==0 do aE=aE+1 end;aE=aE*2^aD+ay.readUint(aD)if g(aE,1)then return-i(aE/2)-1 else return i(aE/2)end end;return ay end;local function aF(aG,aH,aI,aC)local aJ=aG.readUint(2)if aJ>=2 then error("Reserved residual coding method "..aJ)end;local aK=aJ==0 and 4 or 5;local aL=aJ==0 and 0xF or 0x1F;local aM=aG.readUint(4)local aN=2^aM;if aI%aN~=0 then error("Block size not divisible by number of Rice partitions")end;local aO=i(aI/aN)for X=0,aN-1 do local aP=X*aO+(X==0 and aH or 0)local aQ=(X+1)*aO;local aD=aG.readUint(aK)if aD<aL then for aR=aP,aQ-1 do aC[aR+1]=aG.readRiceSignedInt(aD)end else local aS=aG.readUint(5)for aR=aP,aQ-1 do aC[aR+1]=aG.readSignedInt(aS)end end end end;local function aT(aC,aU,aV,aI)for X=#aU,aI-1 do local al=0;for aR=0,#aU-1 do al=al+aC[X-aR]*aU[aR+1]end;aC[X+1]=aC[X+1]+i(al/2^aV)end end;local function aW(aG,aX,aY,aI,aC)for X=1,aX do aC[X]=aG.readSignedInt(aY)end;aF(aG,aX,aI,aC)aT(aC,aw[aX+1],0,aI)end;local function aZ(aG,a_,aY,aI,aC)for X=1,a_ do aC[X]=aG.readSignedInt(aY)end;local b0=aG.readUint(4)+1;local aV=aG.readSignedInt(5)local aU={}for X=1,a_ do aU[X]=aG.readSignedInt(b0)end;aF(aG,a_,aI,aC)aT(aC,aU,aV,aI)end;local function b1(aG,aY,aI,aC)aG.readUint(1)local type=aG.readUint(6)local aV=aG.readUint(1)if aV==1 then while aG.readUint(1)==0 do aV=aV+1 end end;aY=aY-aV;if type==0 then local K=aG.readSignedInt(aY)for X=1,aI do aC[X]=K end elseif type==1 then for X=1,aI do aC[X]=aG.readSignedInt(aY)end elseif 8<=type and type<=12 then aW(aG,type-8,aY,aI,aC)elseif 32<=type and type<=63 then aZ(aG,type-31,aY,aI,aC)else error("Reserved subframe type")end;for X=1,aI do aC[X]=aC[X]*2^aV end end;local function b2(aG,aY,b3,aI,aC)local b4={}for X=1,#aC do b4[X]={}end;if 0<=b3 and b3<=7 then for b5=1,#aC do b1(aG,aY,aI,b4[b5])end elseif 8<=b3 and b3<=10 then b1(aG,aY+(b3==9 and 1 or 0),aI,b4[1])b1(aG,aY+(b3==9 and 0 or 1),aI,b4[2])if b3==8 then for X=1,aI do b4[2][X]=b4[1][X]-b4[2][X]end elseif b3==9 then for X=1,aI do b4[1][X]=b4[1][X]+b4[2][X]end elseif b3==10 then for X=1,aI do local b6=b4[2][X]local b7=b4[1][X]-i(b6/2)b4[2][X]=b7;b4[1][X]=b7+b6 end end else error("Reserved channel assignment")end;for b5=1,#aC do for X=1,aI do local b8=b4[b5][X]if b8>=2^(aY-1)then b8=b8-2^aY end;aC[b5][X]=b8/2^aY end end end;local function b9(aG,ba,aY,bb,bc)local bd={}for X=1,ba do bd[X]={}end;local aB=aG.readByte()if aB==nil then return false end;local be=aB*64+aG.readUint(6)if be~=0x3FFE then error("Sync code expected")end;aG.readUint(2)local bf=aG.readUint(4)local bg=aG.readUint(4)local b3=aG.readUint(4)aG.readUint(4)aB=aG.readUint(8)local bh=-1;for X=7,0,-1 do if not g(aB,2^X)then break end;bh=bh+1 end;for X=1,bh do aG.readUint(8)end;local aI;if bf==1 then aI=192 elseif 2<=bf and bf<=5 then aI=576*2^(bf-2)elseif bf==6 then aI=aG.readUint(8)+1 elseif bf==7 then aI=aG.readUint(16)+1 elseif 8<=bf and bf<=15 then aI=256*2^(bf-8)else error("Reserved block size")end;if bg==12 then aG.readUint(8)elseif bg==13 or bg==14 then aG.readUint(16)end;aG.readUint(8)b2(aG,aY,b3,aI,bd)aG.alignToByte()aG.readUint(16)if bc then bc(bd)else for K=1,ba do local _=#bb[K]for X=1,aI do bb[K][_+X]=bd[K][X]end end end;return true end;function av(aG,bc)local bd={}local V=1;local aB;aB,V=a8(aG,V,4,false,true)if aB~=0x664C6143 then error("Invalid magic string")end;local bi,ba,aY,bj;local bk=false;local bl={}while not bk do aB,V=w(aG,V),V+1;bk=g(aB,0x80)local type=c(aB,0x7F)local bm;bm,V=a8(aG,V,3,false,true)if type==0 then V=V+10;bi,V=a8(aG,V,2,false,true)bi=bi*16+f(w(aG,V),4)ba=c(f(w(aG,V),1),7)+1;aY=c(w(aG,V),1)*16+f(w(aG,V+1),4)+1;bj,V=a8(aG,V+2,4,false,true)bj=bj+c(w(aG,V-5),15)*2^32;V=V+16 elseif type==4 then local bn;bl.vendor,bn,V=u("<s4I4",aG,V)for X=1,bn do local U;U,V=T(u("<s4",aG,V))local a7,Y=U:match"^([^=]+)=(.*)$"if a7 then bl[R[a7:lower()]or a7:lower()]=Y end end else V=V+bm end end;if not bi then error("Stream info metadata block absent")end;if aY%8~=0 then error("Sample depth not supported")end;for X=1,ba do bd[X]={}end;if bc then bc(bi,bj)end;aG=ax(aG,V)repeat until not b9(aG,ba,aY,bd,bc)if not bc then return{sampleRate=bi,data=bd,metadata=bl,info={bitDepth=aY,dataType="signed"}}end end end;function F:len()return#self.data[1]/self.sampleRate end;function F:channels()return#self.data end;function F:resample(bi,bo)a(1,bi,"number")bo=a(2,bo,"string","nil")or C.defaultInterpolation;if not ac[bo]then error("bad argument #2 (invalid interpolation type)",2)end;local bp=setmetatable({sampleRate=bi,data={},metadata=a4(self.metadata),info=a4(self.info)},G)local bq=bi/self.sampleRate;local br=#self.data[1]*bq;local bs=ac[bo]local aP=q"utc"for bt,K in ipairs(self.data)do local bu={}for X=1,br do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;local ae=(X-1)/bq+1;if ae%1==0 then bu[X]=K[ae]else bu[X]=Z(bs(K,ae),-1,1)end end;bp.data[bt]=bu end;return bp end;function F:mono()local bp=setmetatable({sampleRate=self.sampleRate,data={{}},metadata=a4(self.metadata),info=a4(self.info)},G)local bv=bp.data[1]local bw=#self.data;local aP=q"utc"for X=1,#self.data[1]do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;local b8=0;for K=1,bw do b8=b8+self.data[K][X]end;bv[X]=b8/bw end;return bp end;function F:concat(...)local bx={self,...}local by={#self.data[1]}local bw=#self.data;for X=2,#bx do a2(X-1,bx[X])if bx[X].sampleRate~=self.sampleRate then bx[X]=bx[X]:resample(self.sampleRate)end;by[X]=#bx[X].data[1]bw=o(bw,#bx[X].data)end;local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for K=1,bw do local b5={}local V=0;for bz=1,#bx do local bA=bx[bz].data[K]if bA then for X=1,by[bz]do b5[V+X]=bA[X]end else for X=1,by[bz]do b5[V+X]=0 end end;V=V+by[bz]end;ay.data[K]=b5 end;return ay end;function F:sub(aP,bk)aP=i(a(1,aP,"number","nil")or 0)bk=i(a(2,bk,"number","nil")or 0)local bB=#self.data[1]/self.sampleRate;if aP<0 then aP=bB+aP end;if bk<=0 then bk=bB+bk end;a.range(aP,0,bB)a.range(bk,0,bB)aP,bk=aP*self.sampleRate+1,bk*self.sampleRate+1;local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for K=1,#self.data do local b5={}local bA=self.data[K]for X=aP,bk do b5[X-aP+1]=bA[X]end;ay.data[K]=b5 end;return ay end;function F:combine(...)local bx={self,...}local bB=#self.data[1]for X=2,#bx do a2(X-1,bx[X])if bx[X].sampleRate~=self.sampleRate then bx[X]=bx[X]:resample(self.sampleRate)end;bB=o(bB,#bx[X].data[1])end;local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)local V=0;for bz=1,#bx do for K=1,#bx[bz].data do local bA,b5=bx[bz].data[K],{}for X=1,bB do b5[X]=bA[X]or 0 end;ay.data[V+K]=b5 end;V=V+#bx[bz].data end;return ay end;function F:split(...)local bC={}for _,bD in ipairs{...}do a(_,bD,"table")if#bD==0 then error("bad argument #".._.." (cannot use empty table)")end;local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for bE,bF in ipairs(bD)do local bA,b5=self.data[a(bE,bF,"number")],{}if not bA then error("channel "..bF.." (in argument ".._..") out of range",2)end;for X=1,#bA do b5[X]=bA[X]end;ay.data[bE]=b5 end;bC[#bC+1]=ay end;return z(bC)end;function F:mix(bG,...)local bx={self,...}local bB=#self.data[1]local bw=#self.data;for X=2,#bx do a2(X,bx[X])if bx[X].sampleRate~=self.sampleRate then bx[X]=bx[X]:resample(self.sampleRate)end;bB=o(bB,#bx[X].data[1])bw=o(bw,#bx[X].data)end;if type(bG)~="number"then a2(1,bG)if bG.sampleRate~=self.sampleRate then bG=bG:resample(self.sampleRate)end;bB=o(bB,#bG.data[1])bw=o(bw,#bG.data)A(bx,2,bG)bG=1 end;local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for K=1,bw do local b5={}local bA={}for bz=1,#bx do bA[bz]=bx[bz].data[K]end;for X=1,bB do local b8=0;for bz=1,#bx do if bA[bz]then b8=b8+(bA[bz][X]or 0)end end;b5[X]=Z(b8*bG,-1,1)end;ay.data[K]=b5 end;return ay end;function F:rep(bH)if type(self)~="table"and type(bH)=="table"then self,bH=bH,self end;a(1,bH,"number")local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for K=1,#self.data do local bA,b5=self.data[K],{}for _=0,bH-1 do local V=_*#bA;for X=1,#bA do b5[V+X]=bA[X]end end;ay.data[K]=b5 end;return ay end;function F:reverse()local ay=setmetatable({sampleRate=self.sampleRate,data={},metadata=a4(self.metadata),info=a4(self.info)},G)for K=1,#self.data do local bA,b5=self.data[K],{}local bB=#bA;for X=1,bB do b5[bB-X+1]=bA[X]end;ay.data[K]=b5 end;return ay end;local function bI(bJ,V)local bK=2^(bJ.bitDepth-1)local bL=bJ.dataType=="unsigned"and bK or 0;local bM=bJ.audio.data;local bN;if bJ.dataType=="float"then bN=function(an)return an end else bN=function(an)return an*(an<0 and bK or bK-1)+bL end end;local ad={}local bO=#bM;local bB=#bM[1]if V>bB then return nil end;local aP=q"utc"if bJ.interleaved then for _=V,V+bJ.len-1 do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;for K=1,bO do ad[(_-1)*bO+K]=bN(bM[K][_])end end elseif bJ.multiple then for K=1,bO do ad[K]={}for _=V,V+bJ.len-1 do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;local b8=bM[K][_]if not b8 then break end;ad[K][_-V+1]=bN(b8)end end;return V+bJ.len,z(ad)else for K=1,bO do for _=V,V+bJ.len-1 do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;ad[(K-1)*bB+_]=bN(bM[K][_])end end end;return ad end;function F:pcm(bP,bQ,bR)bP=a(1,bP,"number","nil")or 8;bQ=a(2,bQ,"string","nil")or"signed"a(3,bR,"boolean","nil")if bR==nil then bR=true end;if bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;if bQ~="signed"and bQ~="unsigned"and bQ~="float"then error("bad argument #3 (invalid data type)",2)end;if bQ=="float"and bP~=32 then error("bad argument #2 (float audio must have 32-bit depth)",2)end;return bI({audio=self,bitDepth=bP,dataType=bQ,interleaved=bR,len=#self.data[1]},1)end;function F:stream(bS,bP,bQ)bS=a(1,bS,"number","nil")or 131072;bP=a(2,bP,"number","nil")or 8;bQ=a(3,bQ,"string","nil")or"signed"if bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;if bQ~="signed"and bQ~="unsigned"and bQ~="float"then error("bad argument #3 (invalid data type)",2)end;if bQ=="float"and bP~=32 then error("bad argument #2 (float audio must have 32-bit depth)",2)end;local bJ,V={audio=self,bitDepth=bP,dataType=bQ,interleaved=false,multiple=true,len=bS},1;return function()if bJ==nil then return nil end;local bT=V/self.sampleRate;local Y={bI(bJ,V)}if Y[1]==nil then bJ=nil;return nil end;V=B(Y,1)return Y,bT end,#self.data[1]/self.sampleRate end;function F:wav(bP)bP=a(1,bP,"number","nil")or 16;if bP==1 then local U=self:dfpwm(true)return t("<c4Ic4c4IHHIIHHHHIc16c4IIc4I","RIFF",#U+72,"WAVE","fmt ",40,0xFFFE,#self.data,self.sampleRate,self.sampleRate*#self.data/8,j(#self.data/8),1,22,1,N[#self.data]or 0,M.dfpwm,"fact",4,#self.data[1],"data",#U)..U elseif bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;local ad=self:pcm(bP,bP==8 and"unsigned"or"signed",true)local U=""local bU=jit and 7680 or 32768;local bV=((bP==8 and"I"or"i")..bP/8):rep(bU)for X=1,#ad-bU,bU do U=U..bV:pack(z(ad,X,X+bU-1))end;U=U..((bP==8 and"I"or"i")..bP/8):rep(#ad%bU):pack(z(ad,i(#ad/bU)*bU))return t("<c4Ic4c4IHHIIHHc4I","RIFF",#U+36,"WAVE","fmt ",16,1,#self.data,self.sampleRate,self.sampleRate*#self.data*bP/8,#self.data*bP/8,bP,"data",#U)..U end;function F:dfpwm(bR)a(1,bR,"boolean","nil")if bR==nil then bR=true end;if bR then return b.encode(self:pcm(8,"signed",true))else local bW={self:pcm(8,"signed",false)}local bN=b.make_encoder()for X=1,#bW do bW[X]=bN(bW[X])end;return z(bW)end end;G={__index=F,__add=F.combine,__mul=F.rep,__concat=F.concat,__len=F.len,__name="Audio"}function G:__tostring()return"Audio: "..self.sampleRate.." Hz, "..#self.data.." channels, "..#self.data[1]/self.sampleRate.." seconds"end;function C.pcm(ad,bP,bQ,bW,bi,bR,bX)a(1,ad,"string","table")bP=a(2,bP,"number","nil")or 8;bQ=a(3,bQ,"string","nil")or"signed"bW=a(4,bW,"number","nil")or 1;bi=a(5,bi,"number","nil")or 48000;a(6,bR,"boolean","nil")if bR==nil then bR=true end;a(7,bX,"boolean","nil")if bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;if bQ~="signed"and bQ~="unsigned"and bQ~="float"then error("bad argument #3 (invalid data type)",2)end;if bQ=="float"and bP~=32 then error("bad argument #2 (float audio must have 32-bit depth)",2)end;a.range(bW,1)a.range(bi,1)local bY=bP/8;if#ad/(type(ad)=="table"and 1 or bY)%bW~=0 then error("bad argument #1 (uneven amount of data per channel)",2)end;local bB=#ad/(type(ad)=="table"and 1 or bY)/bW;local bU=jit and 7680 or 32768;local bZ=bU*bY;local b_=bX and">"or"<"local c0=bQ=="float"and"f"or(bQ=="signed"and"i"or"I")..bY;local bV=b_..x(c0,bU)local bK=2^(bP-1)local ay=setmetatable({sampleRate=bi,data={},metadata={},info={bitDepth=bP,dataType=bQ}},G)for X=1,bW do ay.data[X]={}end;local V,c1=1,1;local c2={}local c3;if type(ad)=="table"then if bQ=="signed"then function c3()local b8=ad[V]V=V+1;return b8/(b8<0 and bK or bK-1)end elseif bQ=="unsigned"then function c3()local b8=ad[V]V=V+1;return(b8-128)/(b8<128 and bK or bK-1)end else function c3()local b8=ad[V]V=V+1;return b8 end end elseif bQ=="float"then function c3()if V>#c2 then if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return b8 end elseif bQ=="signed"then function c3()if V>#c2 then if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return b8/(b8<0 and bK or bK-1)end else function c3()if V>#c2 then if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return(b8-128)/(b8<128 and bK or bK-1)end end;local aP=q"utc"if bR and bW>1 then local an=ay.data;for X=1,bB do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;for aR=1,bW do an[aR][X]=c3()end end else for aR=1,bW do local bu={}ay.data[aR]=bu;for X=1,bB do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;bu[X]=c3()end end end;return ay end;function C.adpcm(ad,bW,bi,c5,bR,c6,c7)a(1,ad,"string","table")bW=a(2,bW,"number","nil")or 1;bi=a(3,bi,"number","nil")or 48000;a(4,c5,"boolean","nil")if c5==nil then c5=true end;a(5,bR,"boolean","nil")if bR==nil then bR=true end;c6=a(6,c6,"number","table","nil")c7=a(7,c7,"number","table","nil")a.range(bW,1)a.range(bi,1)if c6==nil then c6={}for X=1,bW do c6[X]=0 end elseif type(c6)=="number"then if bW~=1 then error("bad argument #6 (table too short)",2)end;c6={a.range(c6,-32768,32767)}else if bW>#c6 then error("bad argument #6 (table too short)",2)end;for X=1,bW do a.range(c6[X],-32768,32767)end end;if c7==nil then c7={}for X=1,bW do c7[X]=0 end elseif type(c7)=="number"then if bW~=1 then error("bad argument #7 (table too short)",2)end;c7={a.range(c7,0,88)}else if bW>#c7 then error("bad argument #7 (table too short)",2)end;for X=1,bW do a.range(c7[X],0,88)end end;local V=1;local c3,c2,bB;if type(ad)=="string"then function c3()if c2 then local Y=c2;c2=nil;return Y else local c8=w(ad,V)V=V+1;if c5 then c2,c8=c(c8,0x0F),f(c8,4)else c2,c8=f(c8,4),c(c8,0x0F)end;return c8 end end;bB=i(#ad*2/bW)else function c3()local Y=ad[V]V=V+1;return Y end;bB=#ad/bW end;local ay=setmetatable({sampleRate=bi,data={},metadata={},info={bitDepth=16,dataType="signed"}},G)local c9={}local aP=q"utc"if bR then local an=ay.data;for aR=1,bW do an[aR]={}end;for X=1,bB do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;for aR=1,bW do local ca=c3()c9[aR]=P[c7[aR]]c7[aR]=Z(c7[aR]+O[ca],0,88)local cb=f(ca%8*c9[aR],2)+f(c9[aR],3)if ca>=8 then c6[aR]=Z(c6[aR]-cb,-32768,32767)else c6[aR]=Z(c6[aR]+cb,-32768,32767)end;an[aR][X]=c6[aR]/(c6[aR]<0 and 32768 or 32767)end end else for aR=1,bW do local bu={}local c6,c7,c9=c6[aR],c7[aR],nil;for X=1,bB do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;local ca=c3()c9=P[c7]c7=Z(c7+O[ca],0,88)local cb=f(ca%8*c9,2)+f(c9,3)if ca>=8 then c6=Z(c6-cb,-32768,32767)else c6=Z(c6+cb,-32768,32767)end;bu[X]=c6/(c6<0 and 32768 or 32767)end;ay.data[aR]=bu end end;return ay end;function C.msadpcm(ad,cc,bW,bi,cd)a(1,ad,"string")a(2,cc,"number")bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 48000;a(5,cd,"table","nil")a.range(bi,1)local ce,cf;if cd then if type(cd[1])~="table"then error("bad argument #5 (first entry is not a table)",2)end;if type(cd[2])~="table"then error("bad argument #5 (second entry is not a table)",2)end;if#cd[1]~=#cd[2]then error("bad argument #5 (lists are not the same length)",2)end;ce,cf={},{}for X,Y in ipairs(cd[1])do if type(Y)~="number"then error("bad entry #"..X.." in coefficient list 1 (expected number, got "..type(Y)..")",2)end;ce[X-1]=Y end;for X,Y in ipairs(cd[2])do if type(Y)~="number"then error("bad entry #"..X.." in coefficient list 2 (expected number, got "..type(Y)..")",2)end;cf[X-1]=Y end else ce,cf={[0]=256,512,0,192,240,460,392},{[0]=0,-256,0,64,0,-208,-232}end;local ay=setmetatable({sampleRate=bi,data={{},bW==2 and{}or nil},metadata={},info={bitDepth=16,dataType="signed"}},G)local cg,b7=ay.data[1],ay.data[2]local aP=q"utc"for _=1,#ad,cc do if bW==2 then local ch,ci,cj,ck,cl,cm,cn,co=u("<BBhhhhhh",ad,_)local cp,cq,cr,cs=ce[ch],cf[ch],ce[ci],cf[ci]cg[#cg+1]=cn/(cn<0 and 32768 or 32767)cg[#cg+1]=cl/(cl<0 and 32768 or 32767)b7[#b7+1]=co/(co<0 and 32768 or 32767)b7[#b7+1]=cm/(cm<0 and 32768 or 32767)for X=14,cc-1 do local c8=w(ad,_+X)local ct,cu=f(c8,4),c(c8,0x0F)if ct>=8 then ct=ct-16 end;if cu>=8 then cu=cu-16 end;local c6=Z(i((cl*cp+cn*cq)/256)+ct*cj,-32768,32767)cg[#cg+1]=c6/(c6<0 and 32768 or 32767)cn,cl=cl,c6;cj=o(i(Q[ct]*cj/256),16)c6=Z(i((cm*cr+co*cs)/256)+cu*ck,-32768,32767)b7[#b7+1]=c6/(c6<0 and 32768 or 32767)co,cm=cm,c6;ck=o(i(Q[cu]*ck/256),16)end elseif bW==1 then local cv,cw,cx,cy=u("<!1Bhhh",ad)local cz,cA=ce[cv],cf[cv]cg[#cg+1]=cy/(cy<0 and 32768 or 32767)cg[#cg+1]=cx/(cx<0 and 32768 or 32767)for X=7,cc-1 do local c8=w(ad,_+X)local ct,cu=f(c8,4),c(c8,0x0F)if ct>=8 then ct=ct-16 end;if cu>=8 then cu=cu-16 end;local c6=Z(i((cx*cz+cy*cA)/256)+ct*cw,-32768,32767)cg[#cg+1]=c6/(c6<0 and 32768 or 32767)cy,cx=cx,c6;cw=o(i(Q[ct]*cw/256),16)c6=Z(i((cx*cz+cy*cA)/256)+cu*cw,-32768,32767)cg[#cg+1]=c6/(c6<0 and 32768 or 32767)cy,cx=cx,c6;cw=o(i(Q[cu]*cw/256),16)end else error("Unsupported number of channels: "..bW)end;if q"utc"-aP>3000 then aP=q"utc"sleep(0)end end;return ay end;function C.g711(ad,cB,bW,bi)a(1,ad,"string")a(2,cB,"boolean")bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 8000;local bC={}local bU=jit and 7680 or 32768;local cC=cB and 0xFF or 0x55;for X=1,bW do bC[X]={}end;local aP=q"utc"for X=1,#ad,bU do local cD={w(ad,X,X+bU-1)}for aR=1,#cD do local c8=d(cD[aR],cC)local cE,cF=c(c8,0x0F),h(c8,4,3)if not cB and cF==0 then cE=cE*4+2 else cE=e(cE*2+33,cF)end;if cB then cE=cE-33 end;bC[(X+aR-2)%bW+1][i((X+aR-2)/bW+1)]=cE/(g(c8,0x80)==cB and-0x2000 or 0x2000)end;if q"utc"-aP>3000 then aP=q"utc"sleep(0)end end;return setmetatable({sampleRate=bi,data=bC,metadata={bitDepth=cB and 14 or 13,dataType="signed"},info={}},G)end;function C.dfpwm(ad,bW,bi)a(1,ad,"string")bW=a(2,bW,"number","nil")or 1;bi=a(3,bi,"number","nil")or 48000;a.range(bW,1)a.range(bi,1)local cG={}local cH=b.make_decoder()local V=1;local bk=0;local aP=q"utc"while V<=#ad do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;local aB=cH(v(ad,V,V+6000))if aB==nil or#aB==0 then break end;for X=1,#aB do cG[bk+X]=aB[X]end;bk=bk+#aB;V=V+6000 end;return C.pcm(cG,8,"signed",bW,bi,true,false)end;function C.wav(ad)a(1,ad,"string")local bW,bi,bP,bm,bQ,cc,cd;local aB,V=u("c4",ad)if aB~="RIFF"then error("bad argument #1 (not a WAV file)",2)end;V=V+4;aB,V=u("c4",ad,V)if aB~="WAVE"then error("bad argument #1 (not a WAV file)",2)end;local bl={}while V<=#ad do local cI;aB,cI,V=u("<c4I",ad,V)if aB=="fmt "then local cJ=v(ad,V,V+cI-1)V=V+cI;local bV;bV,bW,bi,cc,bP=u("<HHIxxxxHH",cJ)if bV==1 then bQ=bP==8 and"unsigned"or"signed"elseif bV==2 then bQ="msadpcm"local cK=u("<H",cJ,21)if cK>0 then cd={{},{}}for X=1,cK do cd[1][X],cd[2][X]=u("<hh",cJ,X*4+19)end end elseif bV==3 then bQ="float"elseif bV==6 then bQ="alaw"elseif bV==7 then bQ="ulaw"elseif bV==0x11 then bQ="adpcm"elseif bV==0xFFFE then bP=u("<H",cJ,19)local J=v(cJ,25,40)if J==M.pcm then bQ=bP==8 and"unsigned"or"signed"elseif J==M.dfpwm then bQ="dfpwm"elseif J==M.msadpcm then bQ="msadpcm"elseif J==M.pcm_float then bQ="float"elseif J==M.alaw then bQ="alaw"elseif J==M.ulaw then bQ="ulaw"elseif J==M.adpcm then bQ="adpcm"else error("unsupported WAV file",2)end else error("unsupported WAV file",2)end elseif aB=="data"then local ad=v(ad,V,V+cI-1)if#ad<cI then error("invalid WAV file",2)end;local ay;if bQ=="adpcm"then local cL={}for _=1,#ad,cc do if bW==2 then local cM,cN,cO,cP=u("<hBxhB",ad,_)local cQ={}for X=8,cc-1,8 do local c8=w(ad,_+X)cQ[(X-7)*2-1]=c(c8,0x0F)cQ[(X-6)*2-1]=f(c8,4)c8=w(ad,_+X+1)cQ[(X-5)*2-1]=c(c8,0x0F)cQ[(X-4)*2-1]=f(c8,4)c8=w(ad,_+X+2)cQ[(X-3)*2-1]=c(c8,0x0F)cQ[(X-2)*2-1]=f(c8,4)c8=w(ad,_+X+3)cQ[(X-1)*2-1]=c(c8,0x0F)cQ[X*2-1]=f(c8,4)c8=w(ad,_+X+4)cQ[(X-7)*2]=c(c8,0x0F)cQ[(X-6)*2]=f(c8,4)c8=w(ad,_+X+5)cQ[(X-5)*2]=c(c8,0x0F)cQ[(X-4)*2]=f(c8,4)c8=w(ad,_+X+6)cQ[(X-3)*2]=c(c8,0x0F)cQ[(X-2)*2]=f(c8,4)c8=w(ad,_+X+7)cQ[(X-1)*2]=c(c8,0x0F)cQ[X*2]=f(c8,4)end;cL[#cL+1]=C.adpcm(cQ,bW,bi,false,true,{cM,cO},{cN,cP})else local c6,cR=u("<hB",ad,_)cR=c(cR,0x0F)cL[#cL+1]=C.adpcm(v(ad,_+4,_+cc-1),bW,bi,false,false,c6,cR)end end;ay=cL[1]:concat(z(cL,2))elseif bQ=="msadpcm"then ay=C.msadpcm(ad,cc,bW,bi,cd)elseif bQ=="alaw"or bQ=="ulaw"then ay=C.g711(ad,bQ=="ulaw",bW,bi)elseif bQ=="dfpwm"then ay=C.dfpwm(ad,bW,bi)else ay=C.pcm(ad,bP,bQ,bW,bi,true,false)end;ay.metadata=bl;ay.info={dataType=bQ,bitDepth=bP}return ay elseif aB=="fact"then V=V+cI elseif aB=="LIST"then local type=u("c4",ad,V)if type=="INFO"then local cF=V+cI;V=V+4;while V<cF do local U;type,U,V=u("!2<c4s4Xh",ad,V)if S[type]then bl[S[type]]=tonumber(U)or U end end else V=V+cI end else V=V+cI end end;error("invalid WAV file",2)end;function C.aiff(ad)a(1,ad,"string")local bW,bi,bP,bm,cS,cT,cc;local cU=false;local aB,V=u("c4",ad)if aB~="FORM"then error("bad argument #1 (not an AIFF file)",2)end;V=V+4;aB,V=u("c4",ad,V)if aB=="AIFC"then cU=true elseif aB~="AIFF"then error("bad argument #1 (not an AIFF file)",2)end;local bl={}while V<=#ad do local cI;aB,cI,V=u(">c4I",ad,V)if aB=="COMM"then local cF,cE;bW,bm,bP,cF,cE,V=u(">hIhHI7x",ad,V)if cU then local b8;cT,b8,V=u(">c4s1",ad,V)if#b8%2==0 then V=V+1 end end;bm=bm*bW*i(bP/8)local b8=g(cF,0x8000)cF=(c(cF,0x7FFF)-0x3FFE)%0x800;bi=math.ldexp(cE*(b8 and-1 or 1)/0x100000000000000,cF)elseif aB=="SSND"then cS,cc,V=u(">II",ad,V)local ad=v(ad,V+cS,V+cS+bm-1)if#ad<bm then error("invalid AIFF file",2)end;local ay;if cT==nil or cT=="NONE"then ay=C.pcm(ad,bP,"signed",bW,bi,true,true)elseif cT=="sowt"then ay=C.pcm(ad,bP,"signed",bW,bi,true,false)elseif cT=="fl32"or cT=="FL32"then ay=C.pcm(ad,32,"float",bW,bi,true,true)elseif cT=="alaw"or cT=="ulaw"or cT=="ALAW"or cT=="ULAW"then ay=C.g711(ad,cT=="ulaw"or cT=="ULAW",bW,bi)else error("Unsupported compression scheme "..cT,2)end;ay.metadata=bl;return ay elseif aB=="NAME"then bl.title=v(ad,V,V+cI-1)V=V+cI elseif aB=="AUTH"then bl.artist=v(ad,V,V+cI-1)V=V+cI elseif aB=="(c) "then bl.copyright=v(ad,V,V+cI-1)V=V+cI elseif aB=="ANNO"then bl.comment=v(ad,V,V+cI-1)V=V+cI else V=V+cI end end;error("invalid AIFF file",2)end;function C.au(ad)a(1,ad,"string")local cV,cS,cI,cW,bi,bW=u(">c4IIIII",ad)if cV~=".snd"then error("invalid AU file",2)end;if cW==1 then return C.g711(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),true,bW,bi)elseif cW==2 then return C.pcm(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),8,"signed",bW,bi,true,true)elseif cW==3 then return C.pcm(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),16,"signed",bW,bi,true,true)elseif cW==4 then return C.pcm(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),24,"signed",bW,bi,true,true)elseif cW==5 then return C.pcm(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),32,"signed",bW,bi,true,true)elseif cW==6 then return C.pcm(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),32,"float",bW,bi,true,true)elseif cW==27 then return C.g711(v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),false,bW,bi)else error("unsupported encoding type "..cW,2)end end;function C.flac(ad)a(1,ad,"string")return setmetatable(av(ad),G)end;function C.new(cX,bW,bi)a(1,cX,"number")bW=a(2,bW,"number","nil")or 1;bi=a(3,bi,"number","nil")or 48000;a.range(bW,1)a.range(bi,1)local ay=setmetatable({sampleRate=bi,data={},metadata={},info={}},G)for K=1,bW do local by={}for X=1,cX*bi do by[X]=0 end;ay.data[K]=by end;return ay end;function C.tone(cY,cX,at,cZ,au,bW,bi)a(1,cY,"number")a(2,cX,"number")at=a(3,at,"number","nil")or 1;cZ=a(4,cZ,"string","nil")or"sine"au=a(5,au,"number","nil")or 0.5;bW=a(6,bW,"number","nil")or 1;bi=a(7,bi,"number","nil")or 48000;a.range(at,0,1)local c4=ar[cZ]if not c4 then error("bad argument #4 (invalid wave type)",2)end;a.range(au,0,1)a.range(bW,1)a.range(bi,1)local ay=setmetatable({sampleRate=bi,data={},metadata={},info={}},G)for K=1,bW do local by={}for X=1,cX*bi do by[X]=c4(X/bi,cY,at,au)end;ay.data[K]=by end;return ay end;function C.noise(cX,at,bW,bi)a(1,cX,"number")at=a(2,at,"number","nil")or 1;bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 48000;a.range(at,0,1)a.range(bW,1)a.range(bi,1)local ay=setmetatable({sampleRate=bi,data={},metadata={},info={}},G)local c_=math.random;for K=1,bW do local by={}for X=1,cX*bi do by[X]=(c_()*2-1)*at end;ay.data[K]=by end;return ay end;function C.pack(ad,bP,bQ,bX)a(1,ad,"string","table")bP=a(2,bP,"number","nil")or 8;bQ=a(3,bQ,"string","nil")or"signed"a(4,bX,"boolean","nil")if bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;if bQ~="signed"and bQ~="unsigned"and bQ~="float"then error("bad argument #3 (invalid data type)",2)end;if bQ=="float"and bP~=32 then error("bad argument #2 (float audio must have 32-bit depth)",2)end;local bY=bP/8;local bV=(bX and">"or"<")..(bQ=="float"and"f"or(bQ=="signed"and"i"or"I")..bY)local d0=v(bV,1,1)..v(bV,2):rep(512)local bC=""for X=1,#ad,512 do if#ad<X+512 then bC=bC..t(x(bV,#ad%512),z(ad,X,#ad))else bC=bC..t(d0,z(ad,X,X+511))end end;return bC end;function C.play(bc,d1,d2,...)a(1,bc,"function")a(2,d1,"function","table")a(3,d2,"number","table","nil")local d3={...}if type(d2)=="table"then A(d3,1,d2)d2=nil end;if type(d1)=="table"then A(d3,1,d1)d1=nil end;if#d3==0 then error("bad argument #2 (expected speakers, got nil)",2)end;local d4={}local d5=false;local bz,c8=coroutine.create(function()for cJ,V in bc do d4[#d4+1]={cJ,V}coroutine.yield(d3)end;d5=true end),coroutine.create(function()while not d5 or#d4>0 do while not d4[1]do if d5 then return end;coroutine.yield(d3)end;local d6=B(d4,1)local d7={}if d1 then d1(d6[2])end;d6=d6[1]local d8={}if#d6[1]<96000 then d8={d6}else for X=0,#d6[1]-1,48000 do local cJ={}d8[#d8+1]=cJ;for aR=1,#d6 do local b8,K=d6[aR],{}cJ[aR]=K;for a7=1,48000 do K[a7]=b8[a7+X]end end end end;for d9,cJ in ipairs(d8)do for X,Y in ipairs(d3)do d7[X]=function()local da=peripheral.getName(Y)if _HOST:find("CraftOS-PC v2.6.4")and config and not config.get("standardsMode")then Y.playAudio(cJ[X]or cJ[1],d2)repeat until select(2,s("speaker_audio_empty"))==da else while not Y.playAudio(cJ[X]or cJ[1],d2)do repeat until select(2,s("speaker_audio_empty"))==da end end end end;parallel.waitForAll(z(d7))end end end)local db,dc,dd;local de,df={{}},{{}}repeat if#de>0 then local dg=B(de,1)if dc==d3 then dc=nil;A(de,1,dg)end;if dc==nil or dg[1]==dc then db,dc=coroutine.resume(bz,z(dg,1,dg.n))if not db then error(dc,2)end end end;if#df>0 then local dg=B(df,1)if dd==d3 then dd=nil;A(df,1,dg)end;if dd==nil or dg[1]==dd then db,dd=coroutine.resume(c8,z(dg,1,dg.n))if not db then error(dd,2)end end end;if coroutine.status(c8)=="suspended"and(#de==0 or#df==0)then if dc~=nil and dd~=nil then local dg=y(s())de[#de+1]=dg;df[#df+1]=dg else r("__queue_end")while true do local dg=y(s())if dg[1]=="__queue_end"then break end;de[#de+1]=dg;df[#df+1]=dg end end end until coroutine.status(c8)=="dead"or d5;while coroutine.status(c8)=="suspended"and#df>0 do local dg=B(df,1)if dd==nil or dg[1]==dd then db,dd=coroutine.resume(c8,z(dg,1,dg.n))if not db then error(dd,2)end end end;while coroutine.status(c8)=="suspended"do db,dd=coroutine.resume(c8,s())if not db then error(dd,2)end end end;local dh={{"bbbbbbbb",8,"signed"},{"BBBBBBBB",8,"unsigned"},{"hhhhhhhh",16,"signed"},{"iiiiiiii",32,"signed"},{"ffffffff",32,"float"},{"i3i3i3i3i3i3i3i3",24,"signed"},{"IIIIIIII",32,"unsigned"},{"I3I3I3I3I3I3I3I3",24,"unsigned"},{"HHHHHHHH",16,"unsigned"}}function C.detect(ad)a(1,ad,"string")if ad:match"^RIFF....WAVE"then return"wav"elseif ad:match"^FORM....AIF[FC]"then return"aiff"elseif ad:match"^%.snd"then return"au"elseif ad:match"^fLaC"then return"flac"else for d9,di in pairs(dh)do local dj,dk=di[3]=="unsigned"and 2^(di[2]-1)or 0,di[3]=="float"and 0.001 or 8*2^(di[2]-8)local dl={pcall(u,di[1],ad)}dl[#dl]=nil;if B(dl,1)then local dm,db=true,true;for d9,Y in ipairs(dl)do if Y~=dj then dm=false end;if Y<dj-dk or Y>dj+dk then db=false;break end end;if db and not dm then return"pcm",z(di,2)end end;dl={pcall(u,di[1],ad,#ad-di[2])}dl[#dl]=nil;if B(dl,1)then local dm,db=true,true;for d9,Y in ipairs(dl)do if Y~=dj then dm=false end;if Y<dj-dk or Y>dj+dk then db=false;break end end;if db and not dm then return"pcm",z(di,2)end end end;if ad:match(("\x55"):rep(12))or ad:match(("\xAA"):rep(12))then return"dfpwm"end end;return nil end;function C.stream.pcm(ad,bP,bQ,bW,bi,bX,dn)local d7,d5;if type(ad)=="function"then d7,ad=ad,ad()end;a(1,ad,"string","table")bP=a(2,bP,"number","nil")or 8;bQ=a(3,bQ,"string","nil")or"signed"bW=a(4,bW,"number","nil")or 1;bi=a(5,bi,"number","nil")or 48000;a(6,bX,"boolean","nil")a(7,dn,"boolean","nil")if bP~=8 and bP~=16 and bP~=24 and bP~=32 then error("bad argument #2 (invalid bit depth)",2)end;if bQ~="signed"and bQ~="unsigned"and bQ~="float"then error("bad argument #3 (invalid data type)",2)end;if bQ=="float"and bP~=32 then error("bad argument #2 (float audio must have 32-bit depth)",2)end;a.range(bW,1)a.range(bi,1)if bW==1 then dn=false end;local bY=bP/8;local bB=#ad/(type(ad)=="table"and 1 or bY)/bW;local bU=jit and 7680 or 32768;local bZ=bU*bY;local b_=bX and">"or"<"local c0=bQ=="float"and"f"or(bQ=="signed"and"i"or"I")..bY;local bV=b_..x(c0,bU)local bK=2^(bP-1)local V,c1=1,1;local c2={}local c3;if type(ad)=="table"then if bQ=="signed"then function c3()if d5 then return nil end;if d7 and V>#ad then ad,V=d7(),1;if not ad then d5=true;return nil end end;local b8=ad[V]V=V+1;return b8/(b8<0 and bK or bK-1)end elseif bQ=="unsigned"then function c3()if d5 then return nil end;if d7 and V>#ad then ad,V=d7(),1;if not ad then d5=true;return nil end end;local b8=ad[V]V=V+1;return(b8-128)/(b8<128 and bK or bK-1)end else function c3()if d5 then return nil end;if d7 and V>#ad then ad,V=d7(),1;if not ad then d5=true;return nil end end;local b8=ad[V]V=V+1;return b8 end end elseif bQ=="float"then function c3()if d5 then return nil end;if V>#c2 then if d7 and c1>#ad then ad,c1=d7(),1;if not ad then d5=true;return nil end end;if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return b8 end elseif bQ=="signed"then function c3()if d5 then return nil end;if V>#c2 then if d7 and c1>#ad then ad,c1=d7(),1;if not ad then d5=true;return nil end end;if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return b8/(b8<0 and bK or bK-1)end else function c3()if d5 then return nil end;if V>#c2 then if d7 and c1>#ad then ad,c1=d7(),1;if not ad then d5=true;return nil end end;if c1+bZ>#ad then local c4=b_..x(c0,(#ad-c1+1)/bY)c2={u(c4,ad,c1)}c1=c2[#c2]c2[#c2]=nil else c2={u(bV,ad,c1)}c1=c2[#c2]c2[#c2]=nil end;V=1 end;local b8=c2[V]V=V+1;return(b8-128)/(b8<128 and bK or bK-1)end end;local an={}local bq=48000/bi;local dp=1-math.exp(-(bi/96000)*2*p)local bs=ac[C.defaultInterpolation]for aR=1,dn and 1 or bW do an[aR]=setmetatable({},{__index=function(self,X)if dn then for d9=1,bW do self[X]=(rawget(self,X)or 0)+c3()end;self[X]=self[X]/bW else self[X]=c3()end;return rawget(self,X)end})end;local _=0;local db=true;return function()if not db or d5 then return nil end;for X=_==0 and ap[C.defaultInterpolation]or 1,aq[C.defaultInterpolation]do if dn then local b8=0;for aR=1,bW do local K=c3()if not K then return nil end;b8=b8+K end;an[1][X]=b8/bW else for aR=1,bW do an[aR][X]=c3()if not an[aR][X]then return nil end end end end;local cJ={}for aR=1,#an do cJ[aR]={}end;db=pcall(function()local dq={}for bt=1,#an do local b8=cJ[bt][0]or 0;dq[bt]=b8/(b8<0 and 128 or 127)end;for X=1,48000 do for bt=1,#an do local ae=(X-1)/bq+1;local b8;if ae%1==0 then b8=an[bt][ae]else b8=bs(an[bt],ae)end;local dr=dq[bt]+dp*(b8-dq[bt])cJ[bt][X]=Z(dr*(dr<0 and 128 or 127),-128,127)dq[bt]=b8 end end end)if#cJ[1]==0 then return nil end;_=_+#cJ[1]for bt=1,#an do if C.defaultInterpolation=="sinc"then local a6,by={},#an[bt]for X=-L,0 do a6[X]=an[bt][by+X]end;an[bt]=setmetatable(a6,getmetatable(an[bt]))else local ds,dt=an[bt][#an[bt]-1],an[bt][#an[bt]]an[bt]=setmetatable({},getmetatable(an[bt]))an[bt][-1],an[bt][0]=ds,dt end end;return cJ,(_-#cJ[1])/48000 end,bB/bi end;function C.stream.dfpwm(ad,bi,bW,dn)a(1,ad,"string","function")bi=a(2,bi,"number","nil")or 48000;bW=a(3,bW,"number","nil")or 1;a.range(bi,1)a.range(bW,1)if bW==1 then dn=false end;local cH=b.make_decoder()local V=1;local bk=0;local du=type(ad)=="string"local dv=""return function()local an;if du then if V>#ad then return nil end;an=v(ad,V,V+6000*bW)else while#dv<bi/8*bW do local cJ=ad()if not cJ then if#dv==0 then return nil else break end end;dv=dv..cJ end;an=v(dv,1,6000*bW)dv=v(dv,6000*bW+1)end;local cG=cH(an)if cG==nil or#cG==0 then return nil end;cG[0],bk=bk,cG[#cG]r("nosleep")repeat until"nosleep"==s()local bq=48000/bi;local br=#cG*bq;local bs=ac[C.defaultInterpolation]local dw={{}}if not dn then for aR=1,bW do dw[aR]={}end end;for X=1,br,bW do local _=0;for aR=1,bW do local ae=(X-1)/bq+1;local b8;if ae%1==0 then b8=cG[ae]else b8=Z(bs(cG,ae),-128,127)end;if dn then _=_+b8 else dw[aR][j(X/bW)]=b8 end end;if dn then dw[1][j(X/bW)]=_/bW end end;r("nosleep")repeat until"nosleep"==s()local bT=V;V=V+6000*bW;return dw,bT*8/bi/bW end,du and#ad*8/bi/bW end;function C.stream.msadpcm(dx,cc,bW,bi,dn,cd)a(1,dx,"string","function")a(2,cc,"number")bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 48000;a(5,dn,"boolean","nil")a(6,cd,"table","nil")a.range(bi,1)local dy=type(dx)=="function"local ce,cf;if cd then if type(cd[1])~="table"then error("bad argument #5 (first entry is not a table)",2)end;if type(cd[2])~="table"then error("bad argument #5 (second entry is not a table)",2)end;if#cd[1]~=#cd[2]then error("bad argument #5 (lists are not the same length)",2)end;ce,cf={},{}for X,Y in ipairs(cd[1])do if type(Y)~="number"then error("bad entry #"..X.." in coefficient list 1 (expected number, got "..type(Y)..")",2)end;ce[X-1]=Y end;for X,Y in ipairs(cd[2])do if type(Y)~="number"then error("bad entry #"..X.." in coefficient list 2 (expected number, got "..type(Y)..")",2)end;cf[X-1]=Y end else ce,cf={[0]=256,512,0,192,240,460,392},{[0]=0,-256,0,64,0,-208,-232}end;local bq=48000/bi;local bs=ac[C.defaultInterpolation]local _,V=1,0;local ad=dy and dx()or dx;if bW==2 then local dz=cc-14;local dA=j(bi/dz)local dB=cc*dA;local br=i(dz*bq)local dC,dD;return function()if ad==nil then return nil end;local dE=_+dB;local bC={{},not dn and{}or nil}local dF=0;local aP=q"utc"while _<dE do if q"utc"-aP>3000 then r("nosleep")repeat until"nosleep"==s()aP=q"utc"end;if dy and _>#ad then V=V+#ad;_=_-#ad;ad=dx()if ad==nil then return nil end end;if _>#ad then break end;local cg,b7={},{}if dC then for X=1,#dC do cg[X-#dC-1]=dC[X]b7[X-#dD-1]=dD[X]end end;local ch,ci,cj,ck,cl,cm,cn,co=u("<BBhhhhhh",ad,_)local cp,cq,cr,cs=ce[ch],cf[ch],ce[ci],cf[ci]cg[1]=i(cn/(cn<0 and 128 or 127))cg[2]=i(cl/(cl<0 and 128 or 127))b7[1]=i(co/(co<0 and 128 or 127))b7[2]=i(cm/(cm<0 and 128 or 127))for X=14,cc-1 do local c8=w(ad,_+X)local ct,cu=f(c8,4),c(c8,0x0F)if ct>=8 then ct=ct-16 end;if cu>=8 then cu=cu-16 end;local c6=Z(i((cl*cp+cn*cq)/256)+ct*cj,-32768,32767)cg[#cg+1]=i(c6/(c6<0 and 128 or 127))cn,cl=cl,c6;cj=o(i(Q[ct]*cj/256),16)c6=Z(i((cm*cr+co*cs)/256)+cu*ck,-32768,32767)b7[#b7+1]=i(c6/(c6<0 and 128 or 127))co,cm=cm,c6;ck=o(i(Q[cu]*ck/256),16)end;dC,dD=cg,b7;for X=1,br do local ae=(X-1)/bq+1;local by,dG;if ae%1==0 then by,dG=cg[ae],b7[ae]else by,dG=bs(cg,ae),bs(b7,ae)end;if dn then bC[1][dF+X]=Z(i(by+dG/2),-128,127)else bC[1][dF+X],bC[2][dF+X]=Z(i(by),-128,127),Z(i(dG),-128,127)end end;dF=dF+br;_=_+cc end;if#bC[1]==0 then return nil end;return bC,(_+V)/dB end,not dy and#ad/cc*dz/bi or nil elseif bW==1 then local dz=(cc-7)*2;local dA=j(bi/dz)local dB=cc*dA;local br=i(dz*bq)return function()if ad==nil then return nil end;local dE=_+dB;local bC={{}}local dF=0;local aP=q"utc"while _<dE do if q"utc"-aP>3000 then r("nosleep")repeat until"nosleep"==s()aP=q"utc"end;if dy and _>#ad then V=V+#ad;_=_-#ad;ad=dx()if ad==nil then return nil end end;if _>#ad then break end;local cg={}local cv,cw,cx,cy=u("<!1Bhhh",ad)local cz,cA=ce[cv],cf[cv]cg[1]=cy/(cy<0 and 128 or 127)cg[2]=cx/(cx<0 and 128 or 127)for X=7,cc-1 do local c8=w(ad,_+X)local ct,cu=f(c8,4),c(c8,0x0F)if ct>=8 then ct=ct-16 end;if cu>=8 then cu=cu-16 end;local c6=Z(i((cx*cz+cy*cA)/256)+ct*cw,-32768,32767)cg[#cg+1]=c6/(c6<0 and 128 or 127)cy,cx=cx,c6;cw=o(i(Q[ct]*cw/256),16)c6=Z(i((cx*cz+cy*cA)/256)+cu*cw,-32768,32767)cg[#cg+1]=c6/(c6<0 and 128 or 127)cy,cx=cx,c6;cw=o(i(Q[cu]*cw/256),16)end;for X=1,br do local ae=(X-1)/bq+1;if ae%1==0 then bC[1][dF+X]=Z(i(cg[ae]),-128,127)else bC[1][dF+X]=Z(i(bs(cg,ae)),-128,127)end end;dF=dF+br;_=_+cc end;if#bC[1]==0 then return nil end;return bC,(_+V)/dB end,not dy and#ad/cc*dz/bi or nil else error("Unsupported number of channels: "..bW)end end;function C.stream.adpcm(dx,cc,bW,bi,dn)a(1,dx,"string","function")a(2,cc,"number")bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 48000;a(5,dn,"boolean","nil")a.range(bi,1)local dy=type(dx)=="function"local bq=48000/bi;local bs=ac[C.defaultInterpolation]local _,V=1,0;local ad=dy and dx()or dx;local dz=(cc-4*bW)*2/bW;local dA=j(bi/dz)local dB=cc*dA;local br=i(dz*bq)local bk;return function()if ad==nil then return nil end;local dE=_+dB;local bC={{}}if not dn then for X=2,bW do bC[X]={}end end;local dF=0;if dy and dE>#ad then V=V+_-1;dE=dE-_+1;ad=v(ad,_)_=1;while#ad<dE do local an=dx()if not an then break end;ad=ad..an end end;local aP=q"utc"while _<dE do if q"utc"-aP>3000 then r("nosleep")repeat until"nosleep"==s()aP=q"utc"end;if _+bW*4>#ad then break end;local an={}for X=1,bW do an[X]={}end;if bk then for X=1,bW do for aR=1,#bk[X]do an[aR-#bk[X]-1]=bk[X][aR]end end end;local c6,c7,c9={},{},{}for X=1,bW do c6[X],c7[X]=u("<hB",ad,_+(X-1)*4)end;for X=bW*4,cc,bW*4 do local bT=(X-bW*4)/bW*2+1;if#ad<_+X+bW*4 then break end;for aR=1,bW do local dH=u("<I",ad,_+X+(aR-1)*4)for a7=0,7 do local ca=h(dH,a7*4,4)c9[aR]=P[c7[aR]]c7[aR]=Z(c7[aR]+O[ca],0,88)local cb=f(ca%8*c9[aR],2)+f(c9[aR],3)if ca>=8 then c6[aR]=Z(c6[aR]-cb,-32768,32767)else c6[aR]=Z(c6[aR]+cb,-32768,32767)end;an[aR][bT+a7]=c6[aR]/(c6[aR]<0 and 128 or 127)end end end;bk=an;if#an[1]<dz then br=i(#an[1]*bq)end;for X=1,br do local ae=(X-1)/bq+1;local K={}if ae%1==0 then for aR=1,bW do K[aR]=an[aR][ae]end else for aR=1,bW do K[aR]=bs(an[aR],ae)end end;if dn then local _=0;for aR=1,bW do _=_+K[aR]end;bC[1][dF+X]=Z(i(_/bW),-128,127)else for aR=1,bW do bC[aR][dF+X]=Z(i(K[aR]),-128,127)end end end;dF=dF+br;_=_+cc end;if#bC[1]==0 then return nil end;return bC,(_+V)/dB end,not dy and#ad/cc*dz/bi or nil end;function C.stream.g711(dx,cB,bW,bi,dn)a(1,dx,"string","function")a(2,cB,"boolean")bW=a(3,bW,"number","nil")or 1;bi=a(4,bi,"number","nil")or 8000;a(5,dn,"boolean","nil")local bU=jit and 7680 or 32768;local cC=cB and 0xFF or 0x55;local dy=type(dx)=="function"local dv,V="",1;local bq=48000/bi;local bs=ac[C.defaultInterpolation]local bk;return function()local dI=V;local bC={}for X=1,bW do bC[X]={}end;if bk then for X=1,bW do for aR=1,#bk[X]do bC[aR-#bk[X]-1]=bk[X][aR]end end end;local ad;if dy then while#dv<bi*bW do local an=dx()if not dx then if#dv==0 then return nil else break end end;dv=dv..an end;ad=v(dv,1,bi*bW)dv=v(dv,bi*bW+1)else ad=v(dx,V,V+bi*bW-1)end;V=V+bi*bW;local aP=q"utc"for X=1,#ad,bU do local cD={w(ad,X,X+bU-1)}for aR=1,#cD do local c8=d(cD[aR],cC)local cE,cF=c(c8,0x0F),h(c8,4,3)if not cB and cF==0 then cE=cE*4+2 else cE=e(cE*2+33,cF)end;if cB then cE=cE-33 end;bC[(X+aR-2)%bW+1][i((X+aR-2)/bW+1)]=cE/(g(c8,0x80)==cB and-0x40 or 0x40)end;if q"utc"-aP>3000 then aP=q"utc"sleep(0)end end;bk={}for aR=1,bW do bk[aR]={}for X=1,L do bk[aR][X]=bC[aR][#bC[aR]-30+X]end end;local br=i(#bC[1]*bq)local dJ={}for aR=1,bW do dJ[aR]={}end;for X=1,br do local ae=(X-1)/bq+1;local K={}if ae%1==0 then for aR=1,bW do K[aR]=bC[aR][ae]end else for aR=1,bW do K[aR]=bs(bC[aR],ae)end end;if dn then local _=0;for aR=1,bW do _=_+K[aR]end;dJ[1][X]=Z(i(_/bW),-128,127)else for aR=1,bW do dJ[aR][X]=Z(i(K[aR]),-128,127)end end end;return dJ,(dI-1)/bi/bW end,not dy and#dx/bi/bW or nil end;function C.stream.wav(ad,dn,dK)local d7;if type(ad)=="function"then d7,ad=ad,ad()end;a(1,ad,"string")local bW,bi,bP,bm,bQ,cc,cd;local aB,V=u("c4",ad)if aB~="RIFF"then error("bad argument #1 (not a WAV file)",2)end;V=V+4;aB,V=u("c4",ad,V)if aB~="WAVE"then error("bad argument #1 (not a WAV file)",2)end;while V<=#ad do local cI;aB,V=u("c4",ad,V)cI,V=u("<I",ad,V)if aB=="fmt "then local cJ=v(ad,V,V+cI-1)V=V+cI;local bV;bV,bW,bi,cc,bP=u("<HHIxxxxHH",cJ)if bV==1 then bQ=bP==8 and"unsigned"or"signed"elseif bV==2 then bQ="msadpcm"local cK=u("<H",cJ,21)if cK>0 then cd={{},{}}for X=1,cK do cd[1][X],cd[2][X]=u("<hh",cJ,X*4+19)end end elseif bV==3 then bQ="float"elseif bV==6 then bQ="alaw"elseif bV==7 then bQ="ulaw"elseif bV==0x11 then bQ="adpcm"elseif bV==0xFFFE then bP=u("<H",cJ,19)local J=v(cJ,25,40)if J==M.pcm then bQ=bP==8 and"unsigned"or"signed"elseif J==M.dfpwm then bQ="dfpwm"elseif J==M.msadpcm then bQ="msadpcm"elseif J==M.pcm_float then bQ="float"elseif J==M.alaw then bQ="alaw"elseif J==M.ulaw then bQ="ulaw"elseif J==M.adpcm then bQ="adpcm"else error("unsupported WAV file",2)end else error("unsupported WAV file",2)end elseif aB=="data"then local ad=v(ad,V,V+cI-1)if not d7 and#ad<cI then error("invalid WAV file",2)end;if d7 then local dL,c4=ad;ad=function()if dL then c4,dL=dL;return c4 elseif dK then local an=d7()if not an then return nil end;if an:match"^RIFF....WAVE"then return v(an,an:match("^RIFF....WAVE.?data....()"))else return an end else return d7()end end end;if bQ=="adpcm"then return C.stream.adpcm(ad,cc,bW,bi,dn)elseif bQ=="msadpcm"then return C.stream.msadpcm(ad,cc,bW,bi,dn,cd)elseif bQ=="dfpwm"then return C.stream.dfpwm(ad,bi,bW,dn),cI/bW/(bP/8)/bi elseif bQ=="alaw"or bQ=="ulaw"then return C.stream.g711(ad,bQ=="ulaw",bW,bi,dn)else return C.stream.pcm(ad,bP,bQ,bW,bi,false,dn),cI/bW/(bP/8)/bi end elseif aB=="fact"then V=V+cI else V=V+cI end end;error("invalid WAV file",2)end;function C.stream.aiff(ad,dn,dK)local d7;if type(ad)=="function"then d7,ad=ad,ad()end;a(1,ad,"string")a(2,dn,"boolean","nil")local bW,bi,bP,bm,cS,cT,cc;local cU=false;local aB,V=u("c4",ad)if aB~="FORM"then error("bad argument #1 (not an AIFF file)",2)end;V=V+4;aB,V=u("c4",ad,V)if aB=="AIFC"then cU=true elseif aB~="AIFF"then error("bad argument #1 (not an AIFF file)",2)end;while V<=#ad do local cI;aB,V=u("c4",ad,V)cI,V=u(">I",ad,V)if aB=="COMM"then local cF,cE;bW,bm,bP,cF,cE,V=u(">hIhHI7x",ad,V)if cU then local b8;cT,b8,V=u(">c4s1",ad,V)if#b8%2==0 then V=V+1 end end;bm=bm*bW*i(bP/8)local b8=g(cF,0x8000)cF=(c(cF,0x7FFF)-0x3FFE)%0x800;bi=math.ldexp(cE*(b8 and-1 or 1)/0x100000000000000,cF)elseif aB=="SSND"then cS,cc,V=u(">II",ad,V)local ad=v(ad,V+cS,V+cS+bm-1)if not d7 and#ad<bm then error("invalid AIFF file",2)end;if d7 then local dL,c4=ad;ad=function()if dL then c4,dL=dL;return c4 elseif dK then local an=d7()if not an then return nil end;if an:match"^FORM....AIF[FC]"then local _,bT=an:match("^FORM....AIF[FC].-SSND(....)....()")cS=u(">I",_)return v(an,bT+cS)else return an end else return d7()end end end;if cT==nil or cT=="NONE"then return C.stream.pcm(ad,bP,"signed",bW,bi,true,dn),bm/bW/(bP/8)/bi elseif cT=="sowt"then return C.stream.pcm(ad,bP,"signed",bW,bi,true,dn),bm/bW/(bP/8)/bi elseif cT=="fl32"or cT=="FL32"then return C.stream.pcm(ad,32,"float",bW,bi,true,dn),bm/bW/4/bi elseif cT=="alaw"or cT=="ulaw"or cT=="ALAW"or cT=="ULAW"then return C.stream.g711(ad,cT=="ulaw"or cT=="ULAW",bW,bi,dn),bm/bW/bi else error("Unsupported compression scheme "..cT,2)end;return C.stream.pcm(ad,bP,"signed",bW,bi,true,dn),bm/bW/(bP/8)/bi else V=V+cI end end;error("invalid AIFF file",2)end;function C.stream.au(ad,dn,dK)local d7;if type(ad)=="function"then d7,ad=ad,ad()end;a(1,ad,"string")a(2,dn,"boolean","nil")local cV,cS,cI,cW,bi,bW=u(">c4IIIII",ad)if cV~=".snd"then error("invalid AU file",2)end;if d7 then local dL,c4=v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil),nil;ad=function()if dL then c4,dL=dL;return c4 elseif dK then local an=d7()if not an then return nil end;if an:match"^.snd"then return v(an,u(">I",v(an,5,8)),nil)else return an end else return d7()end end else ad=v(ad,cS,cI~=0xFFFFFFFF and cS+cI-1 or nil)end;if cW==1 then return C.stream.g711(ad,true,bW,bi,dn),cI/bW/bi elseif cW==2 then return C.stream.pcm(ad,8,"signed",bW,bi,true,dn),cI/bW/bi elseif cW==3 then return C.stream.pcm(ad,16,"signed",bW,bi,true,dn),cI/bW/2/bi elseif cW==4 then return C.stream.pcm(ad,24,"signed",bW,bi,true,dn),cI/bW/3/bi elseif cW==5 then return C.stream.pcm(ad,32,"signed",bW,bi,true,dn),cI/bW/4/bi elseif cW==6 then return C.stream.pcm(ad,32,"float",bW,bi,true,dn),cI/bW/4/bi elseif cW==27 then return C.stream.g711(ad,false,bW,bi,dn),cI/bW/bi else error("unsupported encoding type "..cW,2)end end;function C.stream.flac(ad,dn)a(1,ad,"string","function")a(2,dn,"boolean","nil")local dM=false;if type(ad)=="function"then ad=setmetatable({str="",fn=ad,final=false,byte=function(self,aP,cF)while aP>#self.str do dM=true;local an=self.fn()dM=false;if not an then self.final=true;return nil end;self.str=self.str..an end;while cF and cF>#self.str do dM=true;local an=self.fn()dM=false;if not an then self.final=true;return nil end;self.str=self.str..an end;return w(self.str,aP,cF)end},{__len=function(self)return self.final and#self.str or math.huge end})end;local function dN(dO,...)local dP=y(coroutine.resume(dO,...))while dP[1]and dM do dP=y(coroutine.resume(dO,coroutine.yield(z(dP,2,dP.n))))end;return z(dP,1,dP.n)end;local dO=coroutine.create(av)local db,bi,bB=dN(dO,ad,coroutine.yield)if not db then error(bi,2)end;local V=0;local bq=48000/bi;local dp=1-math.exp(-(bi/96000)*2*p)local bs=ac[C.defaultInterpolation]local bk={0,0}return function()if coroutine.status(dO)=="dead"then return nil end;local cJ={{}}while#cJ[1]<bi do local db,dP=dN(dO)if not db or dP==nil or dP.sampleRate then break end;r("nosleep")repeat until"nosleep"==s()for K=1,#dP do cJ[K]=cJ[K]or{}local dQ,dR=dP[K],cJ[K]local aP=#dR;dQ[0]=bk[2]dQ[-1]=bk[1]local dq=bk[2]/(bk[2]<0 and 128 or 127)for X=1,i(#dQ*bq)do local an=aP+X;local ae=(X-1)/bq+1;local b8;if ae%1==0 then b8=dQ[ae]else b8=bs(dQ,ae)end;b8=dq+dp*(b8-dq)dq=b8;dR[an]=Z(b8*(b8<0 and 128 or 127),-128,127)end;bk={dQ[#dQ-1],dQ[#dQ]}end;r("nosleep")repeat until"nosleep"==s()end;V=V+#cJ[1]/48000;return cJ,V end,bB/bi end;function C.effects.amplify(cG,dS)a2(1,cG)a(2,dS,"number")if dS==1 then return cG end;local aP=q"utc"for K=1,#cG.data do local b5=cG.data[K]for X=1,#b5 do if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;b5[X]=Z(b5[X]*dS,-1,1)end end;return cG end;function C.effects.speed(cG,dS)a2(1,cG)a(2,dS,"number")if dS==1 then return cG end;local dT=cG.sampleRate;cG.sampleRate=cG.sampleRate*dS;local bp=cG:resample(dT)cG.sampleRate,cG.data=dT,bp.data;return cG end;function C.effects.fade(cG,dU,dV,dW,dX)a2(1,cG)a(2,dU,"number")a(3,dV,"number")a(4,dW,"number")a(5,dX,"number")if dV==1 and dX==1 then return cG end;local dY=q"utc"for K=1,#cG.data do local b5=cG.data[K]local aP=dU*cG.sampleRate;local cE=(dX-dV)/((dW-dU)*cG.sampleRate)for X=aP,dW*cG.sampleRate do if q"utc"-dY>5000 then dY=q"utc"sleep(0)end;b5[X]=Z(b5[X]*(cE*(X-aP)+dV),-1,1)end end;return cG end;function C.effects.invert(cG)a2(1,cG)for K=1,#cG.data do local b5=cG.data[K]for X=1,#b5 do b5[X]=-b5[X]end end;return cG end;function C.effects.normalize(cG,dZ,d_)a2(1,cG)dZ=a(2,dZ,"number","nil")or 1;a(3,d_,"boolean","nil")local e0;local aP,bi=q"utc",cG.sampleRate;if not d_ then local a1=0;for K=1,#cG.data do local b5=cG.data[K]if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;for X=1,#b5 do a1=o(a1,l(b5[X]))end end;e0=dZ/a1 end;for K=1,#cG.data do local b5=cG.data[K]if d_ then local a1=0;for X=1,#b5 do a1=o(a1,l(b5[X]))end;e0=dZ/a1 end;if q"utc"-aP>3000 then aP=q"utc"sleep(0)end;for X=1,#b5 do b5[X]=Z(b5[X]*e0,-1,1)end end;return cG end;function C.effects.center(cG)a2(1,cG)for K=1,#cG.data do local b5=cG.data[K]for X=0,#b5-1,cG.sampleRate do local e1=0;local by=n(#b5-X,cG.sampleRate)for aR=1,by do e1=e1+b5[X+aR]end;e1=e1/by;for aR=1,by do b5[X+aR]=Z(b5[X+aR]-e1,-1,1)end end end;return cG end;function C.effects.trim(cG,e2)a2(1,cG)e2=a(2,e2,"number","nil")or 1/65536;local b8,cF;for X=1,#cG.data[1]do for K=1,#cG.data do if l(cG.data[K][X])>e2 then b8=X;break end end;if b8 then break end end;for X=#cG.data[1],1,-1 do for K=1,#cG.data do if l(cG.data[K][X])>e2 then cF=X;break end end;if cF then break end end;local bp=v(cG,b8/cG.sampleRate,cF/cG.sampleRate)cG.data=bp.data;return cG end;function C.effects.delay(cG,e3,dS)a2(1,cG)a(2,e3,"number")dS=a(3,dS,"number","nil")or 0.5;local e4=i(e3*cG.sampleRate)for K=1,#cG.data do local e5={}local e6=cG.data[K]for X=1,#e6 do e5[X]=e6[X]end;for X=e4+1,#e6 do e6[X]=Z(e6[X]+e5[X-e4]*dS,-1,1)end end;return cG end;function C.effects.echo(cG,e3,dS)a2(1,cG)e3=a(2,e3,"number","nil")or 1;dS=a(3,dS,"number","nil")or 0.5;local e4=i(e3*cG.sampleRate)for K=1,#cG.data do local e6=cG.data[K]for X=e4+1,#e6 do e6[X]=Z(e6[X]+e6[X-e4]*dS,-1,1)end end;return cG end;local e7={0,-11.73,19.31,-7.97}local e8={0,0.1313,0.2743,0.31}function C.effects.reverb(cG,e3,e9,ea,eb)a2(1,cG)e3=a(2,e3,"number","nil")or 100;e9=a(3,e9,"number","nil")or 0.3;ea=a(4,ea,"number","nil")or 1;eb=a(5,eb,"number","nil")or 0;for K=1,#cG.data do local al={}local e6=cG.data[K]for _=1,4 do local ec={}local e4=i((e3+e7[_])/1000*cG.sampleRate)local dS=e9-e8[_]for X=1,n(e4,#e6)do ec[X]=e6[X]al[X]=(al[X]or 0)+e6[X]end;for X=e4+1,#e6 do local b8=e6[X]+ec[X-e4]*dS;ec[X]=b8;al[X]=(al[X]or 0)+b8 end end;for X=1,#al do al[X]=al[X]*ea+e6[X]*eb end;local e4=i(0.08927*cG.sampleRate)al[e4+1]=al[e4+1]-0.131*al[1]for X=e4+2,#al do al[X]=al[X]-0.131*al[X-e4]+0.131*al[X+20-e4]end;e6[e4+1]=Z(al[e4+1]-0.131*al[1],-1,1)for X=e4+2,#al do e6[X]=Z(al[X]-0.131*al[X-e4]+0.131*al[X+20-e4],-1,1)end end;return cG end;function C.effects.lowpass(cG,cY)a2(1,cG)a(2,cY,"number")local bz=1-math.exp(-(cY/cG.sampleRate)*2*p)for K=1,#cG.data do local an=cG.data[K]for X=2,#an do local by=an[X-1]an[X]=by+bz*(an[X]-by)end end;return cG end;function C.effects.highpass(cG,cY)a2(1,cG)a(2,cY,"number")local bz=1/(2*p*cY/cG.sampleRate+1)for K=1,#cG.data do local an=cG.data[K]local ed=an[1]for X=2,#an do local ee=an[X]an[X]=bz*(an[X-1]+ee-ed)ed=ee end end;return cG end;return C
